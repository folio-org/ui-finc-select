[
  {
    "comment": "/**\n * ``` javascript\n * import { Interactor } from '@bigtest/interactor';\n * ```\n *\n * In biology, an _interactor_ is defined as part of an organism that\n * natural selection acts upon. A `@bigtest/interactor` interactor\n * defines part of an _app_ that _tests_ act upon.\n *\n * ``` javascript\n * let input = new Interactor('input');\n *\n * await input\n *   .focus()\n *   .fill('some value')\n *   .blur();\n *\n * expect(input.value).to.equal('some value');\n * ```\n *\n * Interactors are [Convergences](/docs/convergence). They directly\n * extend the `Convergence` class and as such are immutable, reusable,\n * and composable.\n *\n * ``` javascript\n * let input = new Interactor('input');\n * let submit = new Interactor('button[type=\"submit\"]');\n *\n * let fillAndSubmit = value => {\n *   return input.fill(value)\n *     .append(submit.click());\n * }\n *\n * await fillAndSubmit('some value');\n * ```\n *\n * Interactors don't have to be narrowly scoped either. The various\n * interaction methods support passing a selector as the first\n * argument.\n *\n * ``` javascript\n * new Interactor('#some-form')\n *   .fill('input[type=\"email\"]', 'email@domain.tld')\n *   .click('button[type=\"submit\"]');\n * ```\n *\n * You can create custom interactors by extending the class...\n *\n * ``` javascript\n * class FormInteractor extends Interactor {\n *   fillEmail(email) {\n *     // return an instance of this interactor to allow chaining\n *     return this.fill('input[type=\"email\"]', email);\n *   }\n *\n *   submit() {\n *     return this.click('button[type=\"submit\"]');\n *   }\n *\n *   fillAndSubmit(email) {\n *     return this\n *       .fillEmail(email)\n *       .submit();\n *   }\n * }\n * ```\n *\n * ... or use the [`interactor`](#interactor) class decorator in\n * conjuction with the various interaction helpers.\n *\n * ``` javascript\n * import { interactor, fillable, clickable } from '@bigtest/interaction';\n *\n * {REPLACE-AT}interactor class FormInteractor {\n *   fillEmail = fillable('input[type=\"email\"]');\n *   submit = clickable('button[type=\"submit\"]');\n *\n *   fillAndSubmit(email) {\n *     return this\n *       .fillEmail(email)\n *       .submit();\n *   }\n * }\n * ```\n */",
    "meta": {
      "range": [
        3127,
        8327
      ],
      "filename": "interactor.js",
      "lineno": 113,
      "columnno": 0,
      "path": "/src",
      "code": {
        "id": "astnode100001929",
        "name": "Interactor",
        "type": "ClassDeclaration",
        "paramnames": [
          "options",
          "previous"
        ]
      }
    },
    "classdesc": "``` javascript\nimport { Interactor } from '@bigtest/interactor';\n```\n\nIn biology, an _interactor_ is defined as part of an organism that\nnatural selection acts upon. A `@bigtest/interactor` interactor\ndefines part of an _app_ that _tests_ act upon.\n\n``` javascript\nlet input = new Interactor('input');\n\nawait input\n  .focus()\n  .fill('some value')\n  .blur();\n\nexpect(input.value).to.equal('some value');\n```\n\nInteractors are [Convergences](/docs/convergence). They directly\nextend the `Convergence` class and as such are immutable, reusable,\nand composable.\n\n``` javascript\nlet input = new Interactor('input');\nlet submit = new Interactor('button[type=\"submit\"]');\n\nlet fillAndSubmit = value => {\n  return input.fill(value)\n    .append(submit.click());\n}\n\nawait fillAndSubmit('some value');\n```\n\nInteractors don't have to be narrowly scoped either. The various\ninteraction methods support passing a selector as the first\nargument.\n\n``` javascript\nnew Interactor('#some-form')\n  .fill('input[type=\"email\"]', 'email@domain.tld')\n  .click('button[type=\"submit\"]');\n```\n\nYou can create custom interactors by extending the class...\n\n``` javascript\nclass FormInteractor extends Interactor {\n  fillEmail(email) {\n    // return an instance of this interactor to allow chaining\n    return this.fill('input[type=\"email\"]', email);\n  }\n\n  submit() {\n    return this.click('button[type=\"submit\"]');\n  }\n\n  fillAndSubmit(email) {\n    return this\n      .fillEmail(email)\n      .submit();\n  }\n}\n```\n\n... or use the [`interactor`](#interactor) class decorator in\nconjuction with the various interaction helpers.\n\n``` javascript\nimport { interactor, fillable, clickable } from '@bigtest/interaction';\n\n@interactor class FormInteractor {\n  fillEmail = fillable('input[type=\"email\"]');\n  submit = clickable('button[type=\"submit\"]');\n\n  fillAndSubmit(email) {\n    return this\n      .fillEmail(email)\n      .submit();\n  }\n}\n```",
    "name": "Interactor",
    "longname": "Interactor",
    "kind": "class",
    "scope": "global",
    "description": "The constructor arguments mimic convergence constructor arguments\nin that new instances receive new `options` in addition to the\n`previous` instance. Publicly, however, an Interactor's only\nconstructing argument is currently `scope`. But that may change\nin the future to support providing an initial timeout or adding\nadditional interactor-specific options.",
    "params": [
      {
        "type": {
          "names": [
            "String",
            "Element",
            "function"
          ]
        },
        "optional": true,
        "description": "The selector or\nelement this interactor is scoped to. When provided a function,\nit is lazily evaluated whenever the scope getter is invoked",
        "name": "scope"
      }
    ]
  },
  {
    "comment": "/**\n   * The default selector or element an interactor is scoped to when a\n   * scope is not provided during initialization.\n   *\n   * ``` javascript\n   * new Interactor().$root //=> document.body\n   * ```\n   *\n   * When extending the `Interactor` class, this static property may\n   * be overridden to define a new default scope.\n   *\n   * ``` javascript\n   * class CustomInteractor extends Interactor {\n   *   static defaultScope = '#some-element';\n   * }\n   *\n   * new CustomInteractor().$root //=> <div id=\"some-element\">...</div>\n   * ```\n   *\n   * @static\n   * @member {String|Element} Interactor.defaultScope\n   * @default document.body\n   */",
    "meta": {
      "filename": "interactor.js",
      "lineno": 269,
      "columnno": 2,
      "path": "/src",
      "code": {}
    },
    "description": "The default selector or element an interactor is scoped to when a\nscope is not provided during initialization.\n\n``` javascript\nnew Interactor().$root //=> document.body\n```\n\nWhen extending the `Interactor` class, this static property may\nbe overridden to define a new default scope.\n\n``` javascript\nclass CustomInteractor extends Interactor {\n  static defaultScope = '#some-element';\n}\n\nnew CustomInteractor().$root //=> <div id=\"some-element\">...</div>\n```",
    "scope": "static",
    "kind": "member",
    "name": "defaultScope",
    "type": {
      "names": [
        "String",
        "Element"
      ]
    },
    "defaultvalue": "document.body",
    "memberof": "Interactor",
    "longname": "Interactor.defaultScope"
  },
  {
    "comment": "/**\n * Returns `true` if the object has common interactor properties\n *\n * ``` javascript\n * let result = maybeInteractor();\n *\n * if (isInteractor(result)) {\n *   await result.login(user);\n * } else {\n *   something(result);\n * }\n * ```\n *\n * @static\n * @alias Interactor.isInteractor\n * @param {Object} obj - A possible interactor object\n * @returns {Boolean}\n */",
    "meta": {
      "range": [
        2357,
        2545
      ],
      "filename": "utils.js",
      "lineno": 94,
      "columnno": 0,
      "path": "/src",
      "code": {
        "id": "astnode100002503",
        "name": "exports.isInteractor",
        "type": "FunctionDeclaration",
        "paramnames": [
          "obj"
        ]
      }
    },
    "description": "Returns `true` if the object has common interactor properties\n\n``` javascript\nlet result = maybeInteractor();\n\nif (isInteractor(result)) {\n  await result.login(user);\n} else {\n  something(result);\n}\n```",
    "scope": "static",
    "alias": "Interactor.isInteractor",
    "params": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "A possible interactor object",
        "name": "obj"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Boolean"
          ]
        }
      }
    ],
    "name": "isInteractor",
    "longname": "Interactor.isInteractor",
    "kind": "function",
    "memberof": "Interactor"
  },
  {
    "comment": "/**\n * Returns `true` when the interactor scope is visually hidden,\n * otherwise returns `false`. When the interactor scope cannot be\n * found, an error will be thrown.\n *\n * ``` html\n * <div id=\"foo\">\n *   ...\n * </div>\n *\n * <div id=\"bar\" style=\"display: none\">\n *   ...\n * </div>\n * ```\n *\n * ``` javascript\n * new Interactor('#foo').isHidden //=> false\n * new Interactor('#bar').isHidden //=> true\n * ```\n *\n * The element is considered NOT visible for HTML `<area>` elements,\n * SVG elements that do not render anything themselves, `display:\n * none` elements, and generally any elements that are not rendered.\n *\n * @member {Boolean} Interactor#isHidden\n * @throws {Error} When the interactor scope cannot be found\n */",
    "meta": {
      "filename": "is-hidden.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Returns `true` when the interactor scope is visually hidden,\notherwise returns `false`. When the interactor scope cannot be\nfound, an error will be thrown.\n\n``` html\n<div id=\"foo\">\n  ...\n</div>\n\n<div id=\"bar\" style=\"display: none\">\n  ...\n</div>\n```\n\n``` javascript\nnew Interactor('#foo').isHidden //=> false\nnew Interactor('#bar').isHidden //=> true\n```\n\nThe element is considered NOT visible for HTML `<area>` elements,\nSVG elements that do not render anything themselves, `display:\nnone` elements, and generally any elements that are not rendered.",
    "kind": "member",
    "name": "isHidden",
    "type": {
      "names": [
        "Boolean"
      ]
    },
    "exceptions": [
      {
        "type": {
          "names": [
            "Error"
          ]
        },
        "description": "When the interactor scope cannot be found"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#isHidden",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Returns `true` when the interactor scope exists in the DOM,\n * otherwise returns `false`.\n *\n * ``` html\n * <div id=\"foo\">\n *   ...\n * </div>\n * ```\n *\n * ``` javascript\n * new Interactor('#foo').isPresent //=> true\n * new Interactor('#bar').isPresent //=> false\n * ```\n *\n * @member {Boolean} Interactor#isPresent\n */",
    "meta": {
      "filename": "is-present.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Returns `true` when the interactor scope exists in the DOM,\notherwise returns `false`.\n\n``` html\n<div id=\"foo\">\n  ...\n</div>\n```\n\n``` javascript\nnew Interactor('#foo').isPresent //=> true\nnew Interactor('#bar').isPresent //=> false\n```",
    "kind": "member",
    "name": "isPresent",
    "type": {
      "names": [
        "Boolean"
      ]
    },
    "memberof": "Interactor",
    "longname": "Interactor#isPresent",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Returns `true` when the interactor scope is NOT visually hidden,\n * otherwise returns `false`. When the interactor scope cannot be\n * found, an error will be thrown.\n *\n * ``` html\n * <div id=\"foo\">\n *   ...\n * </div>\n *\n * <div id=\"bar\" style=\"display: none\">\n *   ...\n * </div>\n * ```\n *\n * ``` javascript\n * new Interactor('#foo').isVisible //=> true\n * new Interactor('#bar').isVisible //=> false\n * ```\n *\n * The element is considered NOT visible for HTML `<area>` elements,\n * SVG elements that do not render anything themselves, `display:\n * none` elements, and generally any elements that are not rendered.\n *\n * @member {Boolean} Interactor#isVisible\n * @throws {Error} When the interactor scope cannot be found\n */",
    "meta": {
      "filename": "is-visible.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Returns `true` when the interactor scope is NOT visually hidden,\notherwise returns `false`. When the interactor scope cannot be\nfound, an error will be thrown.\n\n``` html\n<div id=\"foo\">\n  ...\n</div>\n\n<div id=\"bar\" style=\"display: none\">\n  ...\n</div>\n```\n\n``` javascript\nnew Interactor('#foo').isVisible //=> true\nnew Interactor('#bar').isVisible //=> false\n```\n\nThe element is considered NOT visible for HTML `<area>` elements,\nSVG elements that do not render anything themselves, `display:\nnone` elements, and generally any elements that are not rendered.",
    "kind": "member",
    "name": "isVisible",
    "type": {
      "names": [
        "Boolean"
      ]
    },
    "exceptions": [
      {
        "type": {
          "names": [
            "Error"
          ]
        },
        "description": "When the interactor scope cannot be found"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#isVisible",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Returns the trimmed `textContent` property of an element.\n *\n * ``` html\n * <p>\n *   Hello World!\n * </p>\n * ```\n *\n * ``` javascript\n * new Interactor('p').text //=> \"Hello World!\"\n * ```\n *\n * @member {Boolean} Interactor#text\n * @throws {Error} When the interactor scope cannot be found\n */",
    "meta": {
      "filename": "text.js",
      "lineno": 23,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Returns the trimmed `textContent` property of an element.\n\n``` html\n<p>\n  Hello World!\n</p>\n```\n\n``` javascript\nnew Interactor('p').text //=> \"Hello World!\"\n```",
    "kind": "member",
    "name": "text",
    "type": {
      "names": [
        "Boolean"
      ]
    },
    "exceptions": [
      {
        "type": {
          "names": [
            "Error"
          ]
        },
        "description": "When the interactor scope cannot be found"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#text",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Returns the value of an input element.\n *\n * ``` html\n * <input value=\"Hello World!\" />\n * ```\n *\n * ``` javascript\n * new Interactor('input').value //=> \"Hello World!\"\n * ```\n *\n * @member {Boolean} Interactor#value\n * @throws {Error} When the interactor scope cannot be found\n */",
    "meta": {
      "filename": "value.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Returns the value of an input element.\n\n``` html\n<input value=\"Hello World!\" />\n```\n\n``` javascript\nnew Interactor('input').value //=> \"Hello World!\"\n```",
    "kind": "member",
    "name": "value",
    "type": {
      "names": [
        "Boolean"
      ]
    },
    "exceptions": [
      {
        "type": {
          "names": [
            "Error"
          ]
        },
        "description": "When the interactor scope cannot be found"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#value",
    "scope": "instance"
  },
  {
    "comment": "/**\n   * A `querySelector`-like method that is scoped to the current\n   * interactor. Unlike `querySelector`, this method will throw an\n   * error when the element cannot be found.\n   *\n   * ``` javascript\n   * let page = new Interactor('#page-scope');\n   *\n   * // returns an element matching `#page-scope .some-element`, and\n   * // throws an error if it cannot be found\n   * page.$('.some-element');\n   * ```\n   *\n   * @param {String} selector - Selector string\n   * @throws {Error} When the element or scope cannot be found\n   * @returns {Element} Element found via `querySelector`\n   */",
    "meta": {
      "range": [
        6915,
        6968
      ],
      "filename": "interactor.js",
      "lineno": 222,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100002183",
        "name": "Interactor#$",
        "type": "MethodDefinition",
        "paramnames": [
          "selector"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "A `querySelector`-like method that is scoped to the current\ninteractor. Unlike `querySelector`, this method will throw an\nerror when the element cannot be found.\n\n``` javascript\nlet page = new Interactor('#page-scope');\n\n// returns an element matching `#page-scope .some-element`, and\n// throws an error if it cannot be found\npage.$('.some-element');\n```",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Selector string",
        "name": "selector"
      }
    ],
    "exceptions": [
      {
        "type": {
          "names": [
            "Error"
          ]
        },
        "description": "When the element or scope cannot be found"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Element"
          ]
        },
        "description": "Element found via `querySelector`"
      }
    ],
    "name": "$",
    "longname": "Interactor#$",
    "kind": "function",
    "memberof": "Interactor",
    "scope": "instance"
  },
  {
    "comment": "/**\n   * A `querySelectorAll`-like method that is scoped to the current\n   * interactor and returns an array instead of a nodelist. If\n   * `selector` cannot be found, an empty array is returned. If the\n   * current scope cannot be found, an error is thrown.\n   *\n   * ``` javascript\n   * let list = new Interactor('ul.some-list');\n   *\n   * // returns an array of elements matching `ul.some-list li`; only\n   * // throws an error when `ul.some-list` cannot be found\n   * page.$$('li');\n   * ```\n   *\n   * @param {String} selector - Selector string\n   * @throws {Error} When the interactor scope cannot be found\n   * @returns {Array} Array of elements found via `querySelectorAll`\n   */",
    "meta": {
      "range": [
        7661,
        7716
      ],
      "filename": "interactor.js",
      "lineno": 244,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100002195",
        "name": "Interactor#$$",
        "type": "MethodDefinition",
        "paramnames": [
          "selector"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "A `querySelectorAll`-like method that is scoped to the current\ninteractor and returns an array instead of a nodelist. If\n`selector` cannot be found, an empty array is returned. If the\ncurrent scope cannot be found, an error is thrown.\n\n``` javascript\nlet list = new Interactor('ul.some-list');\n\n// returns an array of elements matching `ul.some-list li`; only\n// throws an error when `ul.some-list` cannot be found\npage.$$('li');\n```",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Selector string",
        "name": "selector"
      }
    ],
    "exceptions": [
      {
        "type": {
          "names": [
            "Error"
          ]
        },
        "description": "When the interactor scope cannot be found"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Array"
          ]
        },
        "description": "Array of elements found via `querySelectorAll`"
      }
    ],
    "name": "$$",
    "longname": "Interactor#$$",
    "kind": "function",
    "memberof": "Interactor",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element first existing in the DOM, then triggers a\n * blur event on that element.\n *\n * ``` html\n * <form ...>\n *   <input type=\"email\" />\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * await new Interactor('input').blur();\n * await new Interactor('form').blur('input[type=\"email\"]');\n * ```\n *\n * @method Interactor#blur\n * @param {String} [selector] - Nested element query selector\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "blurrable.js",
      "lineno": 4,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element first existing in the DOM, then triggers a\nblur event on that element.\n\n``` html\n<form ...>\n  <input type=\"email\" />\n  ...\n</form>\n```\n\n``` javascript\nawait new Interactor('input').blur();\nawait new Interactor('form').blur('input[type=\"email\"]');\n```",
    "kind": "function",
    "name": "blur",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#blur",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element first existing in the DOM, then triggers a\n * click on that element.\n *\n * ``` html\n * <form ...>\n *   <button type=\"submit\">\n *     ...\n *   </button>\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * await new Interactor('button').click();\n * await new Interactor('form').click('[type=\"submit\"]');\n * ```\n *\n * @method Interactor#click\n * @param {String} [selector] - Nested element query selector\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "clickable.js",
      "lineno": 4,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element first existing in the DOM, then triggers a\nclick on that element.\n\n``` html\n<form ...>\n  <button type=\"submit\">\n    ...\n  </button>\n  ...\n</form>\n```\n\n``` javascript\nawait new Interactor('button').click();\nawait new Interactor('form').click('[type=\"submit\"]');\n```",
    "kind": "function",
    "name": "click",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#click",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element first existing in the DOM, then sets its\n * `value` property to the passed value, and triggers both `input` and\n * `change` events for the element.\n *\n * ``` html\n * <form ...>\n *   <input id=\"name\" />\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * await new Interactor('input').fill('value');\n * await new Interactor('form').fill('input#name', 'value');\n * ```\n *\n * @method Interactor#fill\n * @param {String} [selector] - Nested element query selector\n * @param {String} value - Value to set\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "fillable.js",
      "lineno": 5,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element first existing in the DOM, then sets its\n`value` property to the passed value, and triggers both `input` and\n`change` events for the element.\n\n``` html\n<form ...>\n  <input id=\"name\" />\n  ...\n</form>\n```\n\n``` javascript\nawait new Interactor('input').fill('value');\nawait new Interactor('form').fill('input#name', 'value');\n```",
    "kind": "function",
    "name": "fill",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Value to set",
        "name": "value"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#fill",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element existing in the DOM.\n *\n * ``` javascript\n * let $el = await new Interactor().find('.some-element');\n * ```\n *\n * @method Interactor#find\n * @param {String} selector - Element query selector\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "find.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element existing in the DOM.\n\n``` javascript\nlet $el = await new Interactor().find('.some-element');\n```",
    "kind": "function",
    "name": "find",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#find",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on the scope existing in DOM, then returns an instance of\n * this interactor which will converge with an array of elements\n * matching the provided selector.\n *\n * ``` javascript\n * let $listItems = await new Interactor('ul').findAll('li');\n * ```\n *\n * @method Interactor#findAll\n * @param {String} selector - Element query selector\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "find-all.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on the scope existing in DOM, then returns an instance of\nthis interactor which will converge with an array of elements\nmatching the provided selector.\n\n``` javascript\nlet $listItems = await new Interactor('ul').findAll('li');\n```",
    "kind": "function",
    "name": "findAll",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#findAll",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element first existing in the DOM, then triggers a\n * focus event on that element.\n *\n * ``` html\n * <form ...>\n *   <input type=\"email\" />\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * await new Interactor('input').focus();\n * await new Interactor('form').focus('input[type=\"email\"]');\n * ```\n *\n * @method Interactor#focus\n * @param {String} selector - Nested element query selector\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "focusable.js",
      "lineno": 4,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element first existing in the DOM, then triggers a\nfocus event on that element.\n\n``` html\n<form ...>\n  <input type=\"email\" />\n  ...\n</form>\n```\n\n``` javascript\nawait new Interactor('input').focus();\nawait new Interactor('form').focus('input[type=\"email\"]');\n```",
    "kind": "function",
    "name": "focus",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Nested element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#focus",
    "scope": "instance"
  },
  {
    "comment": "/**\n   * Pauses an interactor by halting the convergence while it is\n   * running with an unresolving promise.\n   *\n   * This is a hack which causes the event loop to hang and in some\n   * situations become unresponsive. Consider moving any teardown code\n   * to execute _before_ setup. This way, when a test is finished, the\n   * DOM and state is preserved for interacting with and inspecting.\n   *\n   * @returns {Interactor} An instance of this interactor which will\n   * halt when it encounters this method in the convergence stack\n   */",
    "meta": {
      "range": [
        8263,
        8325
      ],
      "filename": "interactor.js",
      "lineno": 260,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100002207",
        "name": "Interactor#pause",
        "type": "MethodDefinition",
        "paramnames": []
      },
      "vars": {
        "": null
      }
    },
    "description": "Pauses an interactor by halting the convergence while it is\nrunning with an unresolving promise.\n\nThis is a hack which causes the event loop to hang and in some\nsituations become unresponsive. Consider moving any teardown code\nto execute _before_ setup. This way, when a test is finished, the\nDOM and state is preserved for interacting with and inspecting.",
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "An instance of this interactor which will\nhalt when it encounters this method in the convergence stack"
      }
    ],
    "name": "pause",
    "longname": "Interactor#pause",
    "kind": "function",
    "memberof": "Interactor",
    "scope": "instance",
    "params": []
  },
  {
    "comment": "/**\n * Returns a nested interactor scoped to the selector within the\n * current interactor's scope.\n *\n * ``` html\n * <form ...>\n *   <button type=\"submit\">\n *     ...\n *   </button>\n *   ...\n * </form>\n * ```\n\n * ``` javascript\n * await new Interactor('form').scoped('[type=\"submit\"]').click();\n * ```\n *\n * This is especially useful for returning nested interactors from\n * custom methods.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class RadioGroupInteractor {\n *   radio(value) {\n *     return this.scoped(`[type=\"radio\"][value=\"${value}\"]`, {\n *       isDisabled: property('disabled')\n *     });\n *   }\n * }\n * ```\n *\n * ``` javascript\n * radioGroup.radio('option-1').isDisabled //=> Boolean\n * radioGroup.radio('option-1').click() //=> RadioGroupInteractor\n * ```\n *\n * @method Interactor#scoped\n * @param {String} selector - Nested element query selector\n * @param {Object} [descriptors] - Interaction descriptors\n * @returns {Interactor} A new nested interactor instance\n */",
    "meta": {
      "filename": "scoped.js",
      "lineno": 4,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Returns a nested interactor scoped to the selector within the\ncurrent interactor's scope.\n\n``` html\n<form ...>\n  <button type=\"submit\">\n    ...\n  </button>\n  ...\n</form>\n```\n``` javascript\nawait new Interactor('form').scoped('[type=\"submit\"]').click();\n```\n\nThis is especially useful for returning nested interactors from\ncustom methods.\n\n``` javascript\n@interactor class RadioGroupInteractor {\n  radio(value) {\n    return this.scoped(`[type=\"radio\"][value=\"${value}\"]`, {\n      isDisabled: property('disabled')\n    });\n  }\n}\n```\n\n``` javascript\nradioGroup.radio('option-1').isDisabled //=> Boolean\nradioGroup.radio('option-1').click() //=> RadioGroupInteractor\n```",
    "kind": "function",
    "name": "scoped",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "description": "Interaction descriptors",
        "name": "descriptors"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new nested interactor instance"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#scoped",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element first existing in the DOM, then sets the\n * `scrollTop` and/or `scrollLeft` properties of the element, and then\n * finally triggers a scroll event on the element.\n *\n * ``` javascript\n * await new Interactor('#page').scroll({ top: 100 });\n * await new Interactor('#page').scroll('.nested-view', { left: 100 });\n * ```\n *\n * @method Interactor#scroll\n * @param {String} [selector] - Nested element query selector\n * @param {Number} scrollTo.top - Number of pixels to scroll the top-offset\n * @param {Number} scrollTo.left - Number of pixels to scroll the left-offset\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "scrollable.js",
      "lineno": 5,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element first existing in the DOM, then sets the\n`scrollTop` and/or `scrollLeft` properties of the element, and then\nfinally triggers a scroll event on the element.\n\n``` javascript\nawait new Interactor('#page').scroll({ top: 100 });\nawait new Interactor('#page').scroll('.nested-view', { left: 100 });\n```",
    "kind": "function",
    "name": "scroll",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "Number"
          ]
        },
        "description": "Number of pixels to scroll the top-offset",
        "name": "scrollTo.top"
      },
      {
        "type": {
          "names": [
            "Number"
          ]
        },
        "description": "Number of pixels to scroll the left-offset",
        "name": "scrollTo.left"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#scroll",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element first existing in the DOM, then selects a\n * matching option based on the text content, and triggers `change`\n * and `input` events for the select element.\n *\n * ``` html\n * <form ...>\n *   <select id=\"month\">\n *     <option value=\"1\">January</option>\n *     <option value=\"2\">February</option>\n *     <option value=\"3\">March</option>\n *     ...\n *   </select>\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * await new Interactor('select').select('February');\n * await new Interactor('form').fill('select#month', 'March');\n * ```\n *\n * For multiple selects you can pass an array of options you would\n * like to select.\n *\n * ``` html\n * <form ...>\n *   <select id=\"month\" multiple>\n *     <option value=\"1\">January</option>\n *     <option value=\"2\">February</option>\n *     <option value=\"3\">March</option>\n *     ...\n *   </select>\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * await new Interactor('select').select(['February', 'March']);\n * await new Interactor('form').select('select#month', ['February', 'March']);\n * ```\n *\n * @method Interactor#select\n * @param {String} [selector] - Nested element query selector\n * @param {String|String[]} options - Option or array of options text to select\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "selectable.js",
      "lineno": 5,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element first existing in the DOM, then selects a\nmatching option based on the text content, and triggers `change`\nand `input` events for the select element.\n\n``` html\n<form ...>\n  <select id=\"month\">\n    <option value=\"1\">January</option>\n    <option value=\"2\">February</option>\n    <option value=\"3\">March</option>\n    ...\n  </select>\n  ...\n</form>\n```\n\n``` javascript\nawait new Interactor('select').select('February');\nawait new Interactor('form').fill('select#month', 'March');\n```\n\nFor multiple selects you can pass an array of options you would\nlike to select.\n\n``` html\n<form ...>\n  <select id=\"month\" multiple>\n    <option value=\"1\">January</option>\n    <option value=\"2\">February</option>\n    <option value=\"3\">March</option>\n    ...\n  </select>\n  ...\n</form>\n```\n\n``` javascript\nawait new Interactor('select').select(['February', 'March']);\nawait new Interactor('form').select('select#month', ['February', 'March']);\n```",
    "kind": "function",
    "name": "select",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String",
            "Array.<String>"
          ]
        },
        "description": "Option or array of options text to select",
        "name": "options"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#select",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an element first existing in the DOM, then triggers a\n * specified event with optional event init options.\n *\n * ``` javascript\n * await new Interactor('#foo').trigger('customEvent');\n * await new Interactor('#foo').trigger('customEvent', { ... });\n * await new Interactor('#foo').trigger('#bar', 'customEvent');\n * await new Interactor('#foo').trigger('#bar', 'customEvent', { ... });\n * ```\n *\n * @method Interactor#trigger\n * @param {String} [selector] - Nested element query selector\n * @param {String} eventName - Event name or options object\n * @param {Object} [options] - Event init options\n * @returns {Interactor} A new instance with additional convergences\n */",
    "meta": {
      "filename": "triggerable.js",
      "lineno": 38,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Converges on an element first existing in the DOM, then triggers a\nspecified event with optional event init options.\n\n``` javascript\nawait new Interactor('#foo').trigger('customEvent');\nawait new Interactor('#foo').trigger('customEvent', { ... });\nawait new Interactor('#foo').trigger('#bar', 'customEvent');\nawait new Interactor('#foo').trigger('#bar', 'customEvent', { ... });\n```",
    "kind": "function",
    "name": "trigger",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Event name or options object",
        "name": "eventName"
      },
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "description": "Event init options",
        "name": "options"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Interactor"
          ]
        },
        "description": "A new instance with additional convergences"
      }
    ],
    "memberof": "Interactor",
    "longname": "Interactor#trigger",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Creates a property descriptor for interaction methods.\n *\n * ``` javascript\n * function check(selector) {\n *   return action(function(name) {\n *     return this.click(`${selector}[name=\"${name}\"]`);\n *   })\n * }\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class CheckboxGroupInteractor {\n *   check = check('input[type=\"checkbox\"]');\n * }\n * ```\n *\n * ``` javascript\n * new CheckboxGroupinteractor('.checkboxes').check('option-1');\n * ```\n *\n * @function action\n * @param {Function} method - Function body for the interaction method\n * @returns {Object} page-object property descriptor\n */",
    "meta": {
      "filename": "helpers.js",
      "lineno": 30,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Creates a property descriptor for interaction methods.\n\n``` javascript\nfunction check(selector) {\n  return action(function(name) {\n    return this.click(`${selector}[name=\"${name}\"]`);\n  })\n}\n```\n\n``` javascript\n@interactor class CheckboxGroupInteractor {\n  check = check('input[type=\"checkbox\"]');\n}\n```\n\n``` javascript\nnew CheckboxGroupinteractor('.checkboxes').check('option-1');\n```",
    "kind": "function",
    "name": "action",
    "params": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "Function body for the interaction method",
        "name": "method"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "page-object property descriptor"
      }
    ],
    "longname": "action",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning an attribute of an element.\n *\n * ``` html\n * <div class=\"card\" id=\"foo\">\n *   ...\n *   <a class=\"card-link\" href=\"https://example.com\">\n *     ...\n *   </a>\n * </div>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class CardInteractor {\n *   id = attribute('id');\n *   url = attribute('.card-link', 'href');\n * }\n * ```\n *\n * ``` javascript\n * new CardInteractor('.card').id //=> \"foo\"\n * new CardInteractor('.card').url //=> \"https://example.com\"\n * ```\n *\n * @function attribute\n * @param {String} [selector] - Nested element query selector\n * @param {String} attr - Attribute name\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "attribute.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning an attribute of an element.\n\n``` html\n<div class=\"card\" id=\"foo\">\n  ...\n  <a class=\"card-link\" href=\"https://example.com\">\n    ...\n  </a>\n</div>\n```\n\n``` javascript\n@interactor class CardInteractor {\n  id = attribute('id');\n  url = attribute('.card-link', 'href');\n}\n```\n\n``` javascript\nnew CardInteractor('.card').id //=> \"foo\"\nnew CardInteractor('.card').url //=> \"https://example.com\"\n```",
    "kind": "function",
    "name": "attribute",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Attribute name",
        "name": "attr"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "attribute",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for blurring a specific element within a custom\n * interactor class.\n *\n * ``` html\n * <form ...>\n *   <input type=\"email\" />\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   blurEmail = blurrable('input[type=\"email\"]');\n * }\n * ```\n *\n * ``` javascript\n * await new FormInteractor('form').blurEmail();\n * ```\n *\n * @function blurrable\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "blurrable.js",
      "lineno": 30,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for blurring a specific element within a custom\ninteractor class.\n\n``` html\n<form ...>\n  <input type=\"email\" />\n  ...\n</form>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  blurEmail = blurrable('input[type=\"email\"]');\n}\n```\n\n``` javascript\nawait new FormInteractor('form').blurEmail();\n```",
    "kind": "function",
    "name": "blurrable",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "blurrable",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for clicking a specific element within a\n * custom interactor class.\n *\n * ``` html\n * <div class=\"card\">\n *   ...\n *   <a class=\"card-link\" href=\"https://example.com\">\n *     ...\n *   </a>\n * </div>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class CardInteractor {\n *   clickThrough = clickable('.card-link');\n * }\n * ```\n *\n * ``` javascript\n * await new CardInteractor('.card').clickThrough()\n * ```\n *\n * @function clickable\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "clickable.js",
      "lineno": 31,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for clicking a specific element within a\ncustom interactor class.\n\n``` html\n<div class=\"card\">\n  ...\n  <a class=\"card-link\" href=\"https://example.com\">\n    ...\n  </a>\n</div>\n```\n\n``` javascript\n@interactor class CardInteractor {\n  clickThrough = clickable('.card-link');\n}\n```\n\n``` javascript\nawait new CardInteractor('.card').clickThrough()\n```",
    "kind": "function",
    "name": "clickable",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "clickable",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for a collection of nested interactors. A\n * collection interaction takes an index as it's argument and returns\n * a nested interactor scoped to that element.\n *\n * ``` html\n * <ul class=\"checkboxes\">\n *   <li><input type=\"checkbox\" .../></li>\n *   <li><input type=\"checkbox\" .../></li>\n *   <li><input type=\"checkbox\" .../></li>\n * </ul>\n * ```\n\n * ``` javascript\n * {REPLACE-AT}interactor class CheckboxGroupInteractor {\n *   items = collection('input[type=\"checkbox\"]');\n * }\n * ```\n *\n * Nested interactions return instances of the topmost interactor so\n * that the initial chain is never broken.\n *\n * ``` javascript\n * await checkboxGroup\n *   .items(0).click()\n *   .items(1).click();\n * ```\n *\n * Nested interactors also have an additional method, `#only()`, which\n * disables the default nested chaining behavior, but retains any\n * previous interactions.\n *\n * ``` javascript\n * await checkboxGroup\n *   .items(0).click()\n *   .items(1).only()\n *     .focus()\n *     .trigger('keydown', { which: 32 })\n * ```\n *\n * When calling a collection method without an index, an array of\n * un-nested interactors are returned, each corresponding to an\n * element in the DOM at the time the method was invoked.\n *\n * ``` javascript\n * checkboxGroup.items().length // => 3\n *\n * // checks all checkboxes\n * await checkboxGroup.do(function() {\n *   return this.items().reduce((group, item) => {\n *     return group.append(item.click());\n *   }, this);\n * })\n * ```\n *\n * With the second argument, you can define additional interactions\n * using the various interaction helpers.\n *\n * ``` html\n * <ul class=\"cards\">\n *   <li class=\"card\">\n *     ...\n *     <a class=\"card-link\" ...>\n *       ...\n *     </a>\n *   </li>\n * </ul>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class CardsListInteractor {\n *   cards = collection('.card', {\n *     clickThrough: clickable('.card-link')\n *   });\n * }\n * ```\n *\n * You can also use another interactor class.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class CardInteractor {\n *   clickThrough = clickable('.card-link');\n * }\n *\n * {REPLACE-AT}interactor class CardsListInteractor {\n *   cards = collection('.card', CardInteractor);\n * }\n * ```\n *\n * ``` javascript\n * await new CardListinteractor('.cards')\n *   .cards(0).clickThrough();\n * ```\n *\n * The collection interaction creator also accepts a function instead\n * of a selector. This function is invoked with any arguments given to\n * the resulting collection method and **must** return a new selector\n * string. When no arguments are provided, the selector should match\n * multiple elements within the current scope; when arguments are\n * given, the selector should match only one element within the\n * current scope.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class CheckboxGroupInteractor {\n *   items = collection(value => {\n *     return `[type=\"radio\"]${value ? '[value=\"${value}\"]' : ''}`;\n *   })\n * }\n * ```\n *\n * ``` javascript\n * await checkBoxGroup\n *   .items('green').click()\n *   .items('red').click();\n * ```\n *\n * @function collection\n * @param {String|Function} selector - Element query selector or\n * function that returns a selector\n * @param {Object} [descriptors] - Interaction descriptors\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "collection.js",
      "lineno": 4,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for a collection of nested interactors. A\ncollection interaction takes an index as it's argument and returns\na nested interactor scoped to that element.\n\n``` html\n<ul class=\"checkboxes\">\n  <li><input type=\"checkbox\" .../></li>\n  <li><input type=\"checkbox\" .../></li>\n  <li><input type=\"checkbox\" .../></li>\n</ul>\n```\n``` javascript\n@interactor class CheckboxGroupInteractor {\n  items = collection('input[type=\"checkbox\"]');\n}\n```\n\nNested interactions return instances of the topmost interactor so\nthat the initial chain is never broken.\n\n``` javascript\nawait checkboxGroup\n  .items(0).click()\n  .items(1).click();\n```\n\nNested interactors also have an additional method, `#only()`, which\ndisables the default nested chaining behavior, but retains any\nprevious interactions.\n\n``` javascript\nawait checkboxGroup\n  .items(0).click()\n  .items(1).only()\n    .focus()\n    .trigger('keydown', { which: 32 })\n```\n\nWhen calling a collection method without an index, an array of\nun-nested interactors are returned, each corresponding to an\nelement in the DOM at the time the method was invoked.\n\n``` javascript\ncheckboxGroup.items().length // => 3\n\n// checks all checkboxes\nawait checkboxGroup.do(function() {\n  return this.items().reduce((group, item) => {\n    return group.append(item.click());\n  }, this);\n})\n```\n\nWith the second argument, you can define additional interactions\nusing the various interaction helpers.\n\n``` html\n<ul class=\"cards\">\n  <li class=\"card\">\n    ...\n    <a class=\"card-link\" ...>\n      ...\n    </a>\n  </li>\n</ul>\n```\n\n``` javascript\n@interactor class CardsListInteractor {\n  cards = collection('.card', {\n    clickThrough: clickable('.card-link')\n  });\n}\n```\n\nYou can also use another interactor class.\n\n``` javascript\n@interactor class CardInteractor {\n  clickThrough = clickable('.card-link');\n}\n\n@interactor class CardsListInteractor {\n  cards = collection('.card', CardInteractor);\n}\n```\n\n``` javascript\nawait new CardListinteractor('.cards')\n  .cards(0).clickThrough();\n```\n\nThe collection interaction creator also accepts a function instead\nof a selector. This function is invoked with any arguments given to\nthe resulting collection method and **must** return a new selector\nstring. When no arguments are provided, the selector should match\nmultiple elements within the current scope; when arguments are\ngiven, the selector should match only one element within the\ncurrent scope.\n\n``` javascript\n@interactor class CheckboxGroupInteractor {\n  items = collection(value => {\n    return `[type=\"radio\"]${value ? '[value=\"${value}\"]' : ''}`;\n  })\n}\n```\n\n``` javascript\nawait checkBoxGroup\n  .items('green').click()\n  .items('red').click();\n```",
    "kind": "function",
    "name": "collection",
    "params": [
      {
        "type": {
          "names": [
            "String",
            "function"
          ]
        },
        "description": "Element query selector or\nfunction that returns a selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "description": "Interaction descriptors",
        "name": "descriptors"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "collection",
    "scope": "global"
  },
  {
    "comment": "/**\n * Creates a property descriptor for interaction property getters.\n *\n * ``` javascript\n * function data(key, selector) {\n *   return computed(function() {\n *     return this.$(selector).dataset[key];\n *   })\n * }\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   username = data('user', '#user-info');\n * }\n * ```\n *\n * @function computed\n * @param {Function} getter - Property getter\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "helpers.js",
      "lineno": 1,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Creates a property descriptor for interaction property getters.\n\n``` javascript\nfunction data(key, selector) {\n  return computed(function() {\n    return this.$(selector).dataset[key];\n  })\n}\n```\n\n``` javascript\n@interactor class PageInteractor {\n  username = data('user', '#user-info');\n}\n```",
    "kind": "function",
    "name": "computed",
    "params": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "Property getter",
        "name": "getter"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "computed",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning the number of elements found via a\n * query selector. Will throw an error if the interactor scope cannot\n * be found.\n *\n * ``` html\n * <ul >\n *   <li>...</li>\n *   <li>...</li>\n *   <li>...</li>\n * </ul>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class ListInteractor {\n *   size = count('li');\n * }\n * ```\n *\n * ``` javascript\n * new ListInteractor('ul').size //=> 3\n * ```\n *\n * @function count\n * @param {String} selector - Element query selector\n * @throws {Error} When the interactor scope cannot be found\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "count.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning the number of elements found via a\nquery selector. Will throw an error if the interactor scope cannot\nbe found.\n\n``` html\n<ul >\n  <li>...</li>\n  <li>...</li>\n  <li>...</li>\n</ul>\n```\n\n``` javascript\n@interactor class ListInteractor {\n  size = count('li');\n}\n```\n\n``` javascript\nnew ListInteractor('ul').size //=> 3\n```",
    "kind": "function",
    "name": "count",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "exceptions": [
      {
        "type": {
          "names": [
            "Error"
          ]
        },
        "description": "When the interactor scope cannot be found"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "count",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for setting the value of a specific element\n * within a custom interactor class.\n *\n * ``` html\n * <form ...>\n *   <input id=\"name\" />\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   fillName = fillable('input#name');\n * }\n * ```\n *\n * ``` javascript\n * await new FormInteractor('form').fillName('value');\n * ```\n *\n * @function fillable\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "fillable.js",
      "lineno": 75,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for setting the value of a specific element\nwithin a custom interactor class.\n\n``` html\n<form ...>\n  <input id=\"name\" />\n  ...\n</form>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  fillName = fillable('input#name');\n}\n```\n\n``` javascript\nawait new FormInteractor('form').fillName('value');\n```",
    "kind": "function",
    "name": "fillable",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "fillable",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for finding a specific element within a custom\n * interactor class.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   heading = find('h1.heading');\n * }\n * ```\n *\n * ``` javascript\n * let $heading = new PageInteractor().heading;\n * ```\n *\n * @function find\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "find.js",
      "lineno": 20,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for finding a specific element within a custom\ninteractor class.\n\n``` javascript\n@interactor class PageInteractor {\n  heading = find('h1.heading');\n}\n```\n\n``` javascript\nlet $heading = new PageInteractor().heading;\n```",
    "kind": "function",
    "name": "find",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "find",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for finding a specific set of elements within a\n * custom interactor class.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class ListInteractor {\n *   items = findAll('li');\n * }\n * ```\n *\n * ``` javascript\n * let $listItems = new ListInteractor('ul').items;\n * ```\n *\n * @function findAll\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "find-all.js",
      "lineno": 22,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for finding a specific set of elements within a\ncustom interactor class.\n\n``` javascript\n@interactor class ListInteractor {\n  items = findAll('li');\n}\n```\n\n``` javascript\nlet $listItems = new ListInteractor('ul').items;\n```",
    "kind": "function",
    "name": "findAll",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "findAll",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for focusing a specific element within a custom\n * interactor class.\n *\n * ``` html\n * <form ...>\n *   <input type=\"email\" />\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   focusEmail = focusable('input[type=\"email\"]');\n * }\n * ```\n *\n * ``` javascript\n * await new FormInteractor('form').focusEmail();\n * ```\n *\n * @function focusable\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "focusable.js",
      "lineno": 30,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for focusing a specific element within a custom\ninteractor class.\n\n``` html\n<form ...>\n  <input type=\"email\" />\n  ...\n</form>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  focusEmail = focusable('input[type=\"email\"]');\n}\n```\n\n``` javascript\nawait new FormInteractor('form').focusEmail();\n```",
    "kind": "function",
    "name": "focusable",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "focusable",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning `true` or `false` when an element\n * has a specific class.\n *\n * ``` html\n * <form class=\"error\" ...>\n *   <input id=\"name\" class=\"error\" />\n *   <input type=\"email\" id=\"email\" />\n * </form>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   hasErrors = hasClass('error'); // applies to the root\n *   hasNameError = hasClass('input#name', 'error');\n *   hasEmailError = hasClass('input#email', 'error');\n * }\n * ```\n *\n * ``` javascript\n * new FormInteractor('form').hasErrors //=> true\n * new FormInteractor('form').hasNameError //=> true\n * new FormInteractor('form').hasEmailError //=> false\n * ```\n *\n * @function hasClass\n * @param {String} [selector] - Nested element query selector\n * @param {String} className - Classname to check for\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "has-class.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning `true` or `false` when an element\nhas a specific class.\n\n``` html\n<form class=\"error\" ...>\n  <input id=\"name\" class=\"error\" />\n  <input type=\"email\" id=\"email\" />\n</form>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  hasErrors = hasClass('error'); // applies to the root\n  hasNameError = hasClass('input#name', 'error');\n  hasEmailError = hasClass('input#email', 'error');\n}\n```\n\n``` javascript\nnew FormInteractor('form').hasErrors //=> true\nnew FormInteractor('form').hasNameError //=> true\nnew FormInteractor('form').hasEmailError //=> false\n```",
    "kind": "function",
    "name": "hasClass",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Classname to check for",
        "name": "className"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "hasClass",
    "scope": "global"
  },
  {
    "comment": "/**\n * ``` javascript\n * import { interactor } from '@bigtest/interactor';\n * ```\n *\n * Creates a custom interactor class from methods and properties of\n * another class. Instance initializers that define property\n * descriptors will have their descriptors added to the custom class's\n * prototype.\n *\n * ``` javascript\n * import {\n *   interactor,\n *   isPresent,\n *   clickable\n * } from '@bigtest/interactor';\n *\n * {REPLACE-AT}interactor class CustomInteractor {\n *   // optional default scope for this interactor\n *   static defaultScope = '#some-element';\n *\n *   // `isPresent` returns a getter descriptor\n *   hasError = isPresent('div.error');\n *\n *   // `*able` helpers return method descriptors\n *   submit = clickable('button[type=\"submit\"]');\n *\n *   // normal getters and methods work as well\n *   fillForm(name, email) {\n *     return this\n *       .fill('input#name', name)\n *       .fill('input#email', email)\n *       .submit();\n *   }\n * }\n * ```\n *\n * @function interactor\n * @param {Class} Class - Used for creating custom interactions\n * @returns {Class} Custom interactor class\n */",
    "meta": {
      "filename": "decorator.js",
      "lineno": 62,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "``` javascript\nimport { interactor } from '@bigtest/interactor';\n```\n\nCreates a custom interactor class from methods and properties of\nanother class. Instance initializers that define property\ndescriptors will have their descriptors added to the custom class's\nprototype.\n\n``` javascript\nimport {\n  interactor,\n  isPresent,\n  clickable\n} from '@bigtest/interactor';\n\n@interactor class CustomInteractor {\n  // optional default scope for this interactor\n  static defaultScope = '#some-element';\n\n  // `isPresent` returns a getter descriptor\n  hasError = isPresent('div.error');\n\n  // `*able` helpers return method descriptors\n  submit = clickable('button[type=\"submit\"]');\n\n  // normal getters and methods work as well\n  fillForm(name, email) {\n    return this\n      .fill('input#name', name)\n      .fill('input#email', email)\n      .submit();\n  }\n}\n```",
    "kind": "function",
    "name": "interactor",
    "params": [
      {
        "type": {
          "names": [
            "Class"
          ]
        },
        "description": "Used for creating custom interactions",
        "name": "Class"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Class"
          ]
        },
        "description": "Custom interactor class"
      }
    ],
    "longname": "interactor",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning `true` or `false` within a custom\n * interactor class depending on if the element matches the provided\n * query selector.\n *\n * ``` html\n * <ul class=\"list\">\n *   <li id=\"foo\">...</li>\n *   <li id=\"bar\">...</li>\n *   <li id=\"baz\">...</li>\n * </ul>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class ListInteractor {\n *   isList = is('.list');\n *   isFooFirst = is('#foo', ':first-child');\n *   isBarLast = is('#bar', ':last-child');\n * }\n * ```\n *\n * ``` javascript\n * new ListInteractor('ul').isList //=> true\n * new ListInteractor('ul').isFooFirst //=> true\n * new ListInteractor('ul').isBarLast //=> false\n * ```\n *\n * @function is\n * @param {String} [selector] - Nested element query selector\n * @param {String} match - Matching query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "is.js",
      "lineno": 19,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning `true` or `false` within a custom\ninteractor class depending on if the element matches the provided\nquery selector.\n\n``` html\n<ul class=\"list\">\n  <li id=\"foo\">...</li>\n  <li id=\"bar\">...</li>\n  <li id=\"baz\">...</li>\n</ul>\n```\n\n``` javascript\n@interactor class ListInteractor {\n  isList = is('.list');\n  isFooFirst = is('#foo', ':first-child');\n  isBarLast = is('#bar', ':last-child');\n}\n```\n\n``` javascript\nnew ListInteractor('ul').isList //=> true\nnew ListInteractor('ul').isFooFirst //=> true\nnew ListInteractor('ul').isBarLast //=> false\n```",
    "kind": "function",
    "name": "is",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Matching query selector",
        "name": "match"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "is",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning `true` or `false` within a custom\n * interactor class when a specific element is visually hidden or not.\n *\n * ``` html\n * <div id=\"foo\">\n *   ...\n * </div>\n *\n * <div id=\"bar\" style=\"display: none\">\n *   ...\n * </div>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   isFooHidden = isHidden('#foo');\n *   isBarHidden = isHidden('#bar');\n * }\n * ```\n *\n * ``` javascript\n * new PageInteractor().isFooHidden // => false\n * new PageInteractor().isBarHidden // => true\n * ```\n *\n * The element is considered NOT visible for HTML `<area>` elements,\n * SVG elements that do not render anything themselves, `display:\n * none` elements, and generally any elements that are not rendered.\n *\n * @function isHidden\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "is-hidden.js",
      "lineno": 34,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning `true` or `false` within a custom\ninteractor class when a specific element is visually hidden or not.\n\n``` html\n<div id=\"foo\">\n  ...\n</div>\n\n<div id=\"bar\" style=\"display: none\">\n  ...\n</div>\n```\n\n``` javascript\n@interactor class PageInteractor {\n  isFooHidden = isHidden('#foo');\n  isBarHidden = isHidden('#bar');\n}\n```\n\n``` javascript\nnew PageInteractor().isFooHidden // => false\nnew PageInteractor().isBarHidden // => true\n```\n\nThe element is considered NOT visible for HTML `<area>` elements,\nSVG elements that do not render anything themselves, `display:\nnone` elements, and generally any elements that are not rendered.",
    "kind": "function",
    "name": "isHidden",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "isHidden",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for returning `true` or `false` within a custom\n * interactor class if the element exists in the DOM or not.\n *\n * ``` html\n * <div id=\"foo\">\n *   ...\n * </div>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   isFooPresent = isPresent('#foo');\n *   isBarPresent = isPresent('#bar');\n * }\n * ```\n *\n * ``` javascript\n * new PageInteractor().isFooPresent // => true\n * new PageInteractor().isBarPresent // => false\n * ```\n *\n * @function isPresent\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "is-present.js",
      "lineno": 29,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for returning `true` or `false` within a custom\ninteractor class if the element exists in the DOM or not.\n\n``` html\n<div id=\"foo\">\n  ...\n</div>\n```\n\n``` javascript\n@interactor class PageInteractor {\n  isFooPresent = isPresent('#foo');\n  isBarPresent = isPresent('#bar');\n}\n```\n\n``` javascript\nnew PageInteractor().isFooPresent // => true\nnew PageInteractor().isBarPresent // => false\n```",
    "kind": "function",
    "name": "isPresent",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "isPresent",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning `true` or `false` within a custom\n * interactor class depending on if the element is visible in the DOM.\n *\n * ``` html\n * <div id=\"foo\">\n *   ...\n * </div>\n *\n * <div id=\"bar\" style=\"display: none\">\n *   ...\n * </div>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   isFooVisible = isVisible('#foo');\n *   isBarVisible = isVisible('#bar');\n * }\n * ```\n *\n * ``` javascript\n * new PageInteractor().isFooVisible // => true\n * new PageInteractor().isBarVisible // => false\n * ```\n *\n * The element is considered NOT visible for HTML `<area>` elements,\n * SVG elements that do not render anything themselves, `display:\n * none` elements, and generally any elements that are not rendered.\n *\n * @function isVisible\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "is-visible.js",
      "lineno": 34,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning `true` or `false` within a custom\ninteractor class depending on if the element is visible in the DOM.\n\n``` html\n<div id=\"foo\">\n  ...\n</div>\n\n<div id=\"bar\" style=\"display: none\">\n  ...\n</div>\n```\n\n``` javascript\n@interactor class PageInteractor {\n  isFooVisible = isVisible('#foo');\n  isBarVisible = isVisible('#bar');\n}\n```\n\n``` javascript\nnew PageInteractor().isFooVisible // => true\nnew PageInteractor().isBarVisible // => false\n```\n\nThe element is considered NOT visible for HTML `<area>` elements,\nSVG elements that do not render anything themselves, `display:\nnone` elements, and generally any elements that are not rendered.",
    "kind": "function",
    "name": "isVisible",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "isVisible",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning a property of an element.\n *\n * ``` html\n * <div class=\"card\" style=\"height: 100px\">\n *   ...\n *   <button class=\"card-cta\" disabled>\n *     ...\n *   </button>\n * </div>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class CardInteractor {\n *   height = property('offsetHeight');\n *   isDisabled = property('button.card-cta', 'disabled');\n * }\n * ```\n *\n * ``` javascript\n * new CardInteractor('.card').height //=> 100\n * new CardInteractor('.card').isDisabled //=> true\n * ```\n *\n * @function property\n * @param {String} [selector] - Nested element query selector\n * @param {String} prop - Property name\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "property.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning a property of an element.\n\n``` html\n<div class=\"card\" style=\"height: 100px\">\n  ...\n  <button class=\"card-cta\" disabled>\n    ...\n  </button>\n</div>\n```\n\n``` javascript\n@interactor class CardInteractor {\n  height = property('offsetHeight');\n  isDisabled = property('button.card-cta', 'disabled');\n}\n```\n\n``` javascript\nnew CardInteractor('.card').height //=> 100\nnew CardInteractor('.card').isDisabled //=> true\n```",
    "kind": "function",
    "name": "property",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Nested element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Property name",
        "name": "prop"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "property",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for a single nested interactor.\n *\n * ``` html\n * <form class=\"login-form\">\n *   <input type=\"text\" name=\"username\" />\n *   <input type=\"email\" name=\"email\" />\n *   <button type=\"submit\">Login</button>\n * </form>\n * ```\n\n * ``` javascript\n * {REPLACE-AT}interactor class LoginFormInteractor {\n *   username = scoped('input[name=\"username\"]')\n *   email = scoped('input[name=\"email\"]')\n *   submit = clickable('button[type=\"submit\"]')\n * }\n * ```\n *\n * Nested interactions return instances of the topmost interactor so\n * that the initial chain is never broken.\n *\n * ``` javascript\n * await loginForm\n *   .username.fill('darklord1926')\n *   .email.fill('tom.riddle@hogwarts.edu')\n *   .email.blur()\n *   .submit()\n * ```\n *\n * Nested interactors also have an additional method, `#only()`, which\n * disables the default nested chaining behavior, but retains any\n * previous interactions.\n *\n * ``` javascript\n * await loginForm\n *   .username.fill('h4x0r')\n *   .email.only()\n *     .fill('not@an@email')\n *     .blur()\n * ```\n *\n * With the second argument, you can define additional interactions\n * using the various interaction helpers.\n *\n * ``` html\n * <label class=\"field username-field\">\n *   <span class=\"field-label\">Username:</span>\n *   <input type=\"text\" name=\"username\" />\n * </label>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   username = scoped('.username-field', {\n *     label: text('.field-label'),\n *     fillIn: fillable('input')\n *   })\n * }\n * ```\n *\n * You can also use another interactor class.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FieldInteractor {\n *   label = text('.field-label')\n *\n *   fillIn(value) {\n *     return this.scoped('input')\n *      .focus().fill(value).blur()\n *   }\n * }\n *\n * {REPLACE-AT}interactor class LoginFormInteractor {\n *   username = scoped('.username-field', FieldInteractor)\n *   email = scoped('.email-field', FieldInteractor)\n *   submit = clickable('button[type=\"submit\"]')\n * }\n * ```\n *\n * ``` javascript\n * await loginForm\n *   .username.fillIn('darklord1926')\n *   .email.fillIn('tom.riddle@hogwarts.edu')\n *   .submit()\n * ```\n *\n * @function scoped\n * @param {String} selector - Element query selector\n * @param {Object} [descriptors] - Interaction descriptors\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "scoped.js",
      "lineno": 53,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for a single nested interactor.\n\n``` html\n<form class=\"login-form\">\n  <input type=\"text\" name=\"username\" />\n  <input type=\"email\" name=\"email\" />\n  <button type=\"submit\">Login</button>\n</form>\n```\n``` javascript\n@interactor class LoginFormInteractor {\n  username = scoped('input[name=\"username\"]')\n  email = scoped('input[name=\"email\"]')\n  submit = clickable('button[type=\"submit\"]')\n}\n```\n\nNested interactions return instances of the topmost interactor so\nthat the initial chain is never broken.\n\n``` javascript\nawait loginForm\n  .username.fill('darklord1926')\n  .email.fill('tom.riddle@hogwarts.edu')\n  .email.blur()\n  .submit()\n```\n\nNested interactors also have an additional method, `#only()`, which\ndisables the default nested chaining behavior, but retains any\nprevious interactions.\n\n``` javascript\nawait loginForm\n  .username.fill('h4x0r')\n  .email.only()\n    .fill('not@an@email')\n    .blur()\n```\n\nWith the second argument, you can define additional interactions\nusing the various interaction helpers.\n\n``` html\n<label class=\"field username-field\">\n  <span class=\"field-label\">Username:</span>\n  <input type=\"text\" name=\"username\" />\n</label>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  username = scoped('.username-field', {\n    label: text('.field-label'),\n    fillIn: fillable('input')\n  })\n}\n```\n\nYou can also use another interactor class.\n\n``` javascript\n@interactor class FieldInteractor {\n  label = text('.field-label')\n\n  fillIn(value) {\n    return this.scoped('input')\n     .focus().fill(value).blur()\n  }\n}\n\n@interactor class LoginFormInteractor {\n  username = scoped('.username-field', FieldInteractor)\n  email = scoped('.email-field', FieldInteractor)\n  submit = clickable('button[type=\"submit\"]')\n}\n```\n\n``` javascript\nawait loginForm\n  .username.fillIn('darklord1926')\n  .email.fillIn('tom.riddle@hogwarts.edu')\n  .submit()\n```",
    "kind": "function",
    "name": "scoped",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "description": "Interaction descriptors",
        "name": "descriptors"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "scoped",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for scrollilng a specific element within a\n * custom interactor class.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   scrollSection = scrollable('.scrollview')\n * }\n * ```\n *\n * ``` javascript\n * await new PageInteractor('#page').scrollSection({ top: 100 })\n * ```\n *\n * @function scrollable\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "scrollable.js",
      "lineno": 51,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for scrollilng a specific element within a\ncustom interactor class.\n\n``` javascript\n@interactor class PageInteractor {\n  scrollSection = scrollable('.scrollview')\n}\n```\n\n``` javascript\nawait new PageInteractor('#page').scrollSection({ top: 100 })\n```",
    "kind": "function",
    "name": "scrollable",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "scrollable",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for selecting an option of a specific select\n * element within a custom interactor class.\n *\n * ``` html\n * <form ...>\n *   <select id=\"month\">\n *     <option value=\"1\">January</option>\n *     <option value=\"2\">February</option>\n *     <option value=\"3\">March</option>\n *     ...\n *   </select>\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   selectMonth = selectable('select#month');\n * }\n * ```\n *\n * ``` javascript\n * await new FormInteractor('form').selectMonth('February');\n * ```\n *\n * For multiple selects you can pass an array of options you would\n * like to select.\n *\n * ``` html\n * <form ...>\n *   <select id=\"month\" multiple>\n *     <option value=\"1\">January</option>\n *     <option value=\"2\">February</option>\n *     <option value=\"3\">March</option>\n *     ...\n *   </select>\n *   ...\n * </form>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   selectMonth = selectable('select#month');\n * }\n * ```\n *\n * ``` javascript\n * await new FormInteractor('form').selectMonth(['February', 'March']);\n * ```\n *\n * @function selectable\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "selectable.js",
      "lineno": 117,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for selecting an option of a specific select\nelement within a custom interactor class.\n\n``` html\n<form ...>\n  <select id=\"month\">\n    <option value=\"1\">January</option>\n    <option value=\"2\">February</option>\n    <option value=\"3\">March</option>\n    ...\n  </select>\n  ...\n</form>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  selectMonth = selectable('select#month');\n}\n```\n\n``` javascript\nawait new FormInteractor('form').selectMonth('February');\n```\n\nFor multiple selects you can pass an array of options you would\nlike to select.\n\n``` html\n<form ...>\n  <select id=\"month\" multiple>\n    <option value=\"1\">January</option>\n    <option value=\"2\">February</option>\n    <option value=\"3\">March</option>\n    ...\n  </select>\n  ...\n</form>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  selectMonth = selectable('select#month');\n}\n```\n\n``` javascript\nawait new FormInteractor('form').selectMonth(['February', 'March']);\n```",
    "kind": "function",
    "name": "selectable",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "selectable",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning the trimmed `textContent` property\n * of an element within a custom interactor class.\n *\n * ``` html\n * <h1>\n *   Hello World!\n * </h1>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   heading = text('h1');\n * }\n * ```\n *\n * ``` javascript\n * new PageInteractor().heading //=> \"Hello World!\"\n * ```\n *\n * @function text\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "text.js",
      "lineno": 43,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning the trimmed `textContent` property\nof an element within a custom interactor class.\n\n``` html\n<h1>\n  Hello World!\n</h1>\n```\n\n``` javascript\n@interactor class PageInteractor {\n  heading = text('h1');\n}\n```\n\n``` javascript\nnew PageInteractor().heading //=> \"Hello World!\"\n```",
    "kind": "function",
    "name": "text",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "text",
    "scope": "global"
  },
  {
    "comment": "/**\n * Interaction creator for triggering an event on a specific element\n * within a custom interactor class.\n *\n * ``` javascript\n * {REPLACE-AT}interactor class PageInteractor {\n *   triggerEvent = triggerable('customEvent', { ... });\n *   triggerFooEvent = triggerable('#foo', 'customEvent');\n * }\n * ```\n *\n * ``` javascript\n * await new PageInteractor().triggerEvent();\n * await new PageInteractor().triggerEvent({ ... });\n * await new PageInteractor().triggerFooEvent();\n * await new PageInteractor().triggerFooEvent({ ... });\n * ```\n *\n * @function triggerable\n * @param {String} [selector] - Element query selector\n * @param {String} eventName - Event name or options object\n * @param {Object} [options] - Event init options\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "triggerable.js",
      "lineno": 77,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Interaction creator for triggering an event on a specific element\nwithin a custom interactor class.\n\n``` javascript\n@interactor class PageInteractor {\n  triggerEvent = triggerable('customEvent', { ... });\n  triggerFooEvent = triggerable('#foo', 'customEvent');\n}\n```\n\n``` javascript\nawait new PageInteractor().triggerEvent();\nawait new PageInteractor().triggerEvent({ ... });\nawait new PageInteractor().triggerFooEvent();\nawait new PageInteractor().triggerFooEvent({ ... });\n```",
    "kind": "function",
    "name": "triggerable",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "description": "Element query selector",
        "name": "selector"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Event name or options object",
        "name": "eventName"
      },
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "description": "Event init options",
        "name": "options"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "triggerable",
    "scope": "global"
  },
  {
    "comment": "/**\n * Property creator for returning the value of an input element within\n * a custom interactor class.\n *\n * ``` html\n * <form>\n *   <input id=\"name\" value=\"Foo Bar\" />\n * </form>\n * ```\n *\n * ``` javascript\n * {REPLACE-AT}interactor class FormInteractor {\n *   name = value('input#name');\n * }\n * ```\n *\n * ``` javascript\n * new FormInteractor('form').name //=> \"Foo Bar\"\n * ```\n *\n * @function value\n * @param {String} selector - Element query selector\n * @returns {Object} Property descriptor\n */",
    "meta": {
      "filename": "value.js",
      "lineno": 21,
      "columnno": 0,
      "path": "/src/interactions",
      "code": {}
    },
    "description": "Property creator for returning the value of an input element within\na custom interactor class.\n\n``` html\n<form>\n  <input id=\"name\" value=\"Foo Bar\" />\n</form>\n```\n\n``` javascript\n@interactor class FormInteractor {\n  name = value('input#name');\n}\n```\n\n``` javascript\nnew FormInteractor('form').name //=> \"Foo Bar\"\n```",
    "kind": "function",
    "name": "value",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "Element query selector",
        "name": "selector"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Property descriptor"
      }
    ],
    "longname": "value",
    "scope": "global"
  }
]
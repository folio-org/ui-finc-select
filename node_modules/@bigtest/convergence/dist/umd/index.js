(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.BigTest = global.BigTest || {}, global.BigTest.Convergence = {})));
}(this, (function (exports) { 'use strict';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function convergeOn(assertion, timeout, always) {
  var start = Date.now();
  var interval = 10;
  var stats = {
    start: start,
    runs: 0,
    end: start,
    elapsed: 0,
    always: always,
    timeout: timeout,
    value: undefined
  };
  return new Promise(function (resolve, reject) {
    (function loop() {
      stats.runs += 1;

      try {
        var results = assertion();

        if (results && typeof results.then === 'function') {
          throw new Error('convergent assertion encountered a async function or promise; ' + 'since convergent assertions can run multiple times, you should ' + 'avoid introducing side-effects inside of them');
        }

        var doLoop = Date.now() - start < timeout;

        if (always && doLoop) {
          setTimeout(loop, interval);
        } else if (results === false) {
          throw new Error('convergent assertion returned `false`');
        } else if (!always && !doLoop) {
          throw new Error('convergent assertion was successful, ' + "but exceeded the ".concat(timeout, "ms timeout"));
        } else {
          stats.end = Date.now();
          stats.elapsed = stats.end - start;
          stats.value = results;
          resolve(stats);
        }
      } catch (error) {
        var _doLoop = Date.now() - start < timeout;

        if (!always && _doLoop) {
          setTimeout(loop, interval);
        } else if (always || !_doLoop) {
          reject(error);
        }
      }
    })();
  });
}
function when(assertion) {
  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
  return convergeOn(assertion, timeout, false);
}
function always(assertion) {
  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
  return convergeOn(assertion, timeout, true);
}

function getElapsedSince(start, max) {
  var elapsed = Date.now() - start;

  if (elapsed >= max) {
    throw new Error("convergence exceeded the ".concat(max, "ms timeout"));
  }

  return elapsed;
}



function collectStats(accumulator, stats) {
  accumulator.runs += stats.runs;
  accumulator.elapsed += stats.elapsed;
  accumulator.end = stats.end;
  accumulator.value = stats.value;
  accumulator.queue.push(stats);
  return stats.value;
}

function isConvergence(obj) {
  return !!obj && _typeof(obj) === 'object' && '_queue' in obj && Array.isArray(obj._queue) && 'timeout' in obj && typeof obj.timeout === 'function' && 'run' in obj && typeof obj.run === 'function';
}
function runAssertion(subject, arg, stats) {
  var timeout = stats.timeout - getElapsedSince(stats.start, stats.timeout);
  var assertion = subject.assertion.bind(this, arg);
  var converge = subject.always ? always : when;

  if (subject.always && !subject.last) {
    if (subject.timeout) {
      timeout = Math.min(timeout, subject.timeout);
    } else {
      timeout = Math.max(stats.timeout / 10, 20);
    }
  }

  return converge(assertion, timeout).then(function (convergeStats) {
    return collectStats(stats, convergeStats);
  });
}
function runCallback(subject, arg, stats) {
  var start = Date.now();
  var result = subject.callback.call(this, arg);

  var collectExecStats = function collectExecStats(value) {
    return collectStats(stats, {
      start: start,
      runs: 1,
      end: Date.now(),
      elapsed: getElapsedSince(start, stats.timeout),
      value: value
    });
  };

  if (isConvergence(result)) {
    var timeout = stats.timeout - getElapsedSince(start, stats.timeout);

    if (!subject.last) {
      result = result.do(function (ret) {
        return ret;
      });
    }

    return result.timeout(timeout).run().then(function (convergeStats) {
      return collectStats(stats, convergeStats);
    });
  } else if (result && typeof result.then === 'function') {
    return result.then(collectExecStats);
  } else {
    return collectExecStats(result);
  }
}

var Convergence = function () {
  function Convergence() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var previous = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Convergence);

    if (typeof options === 'number') {
      options = {
        timeout: options
      };
    }

    var _options = options,
        _options$timeout = _options.timeout,
        timeout = _options$timeout === void 0 ? previous._timeout || 2000 : _options$timeout,
        _options$_queue = _options._queue,
        _queue = _options$_queue === void 0 ? [] : _options$_queue;

    _queue = _toConsumableArray(previous._queue || []).concat(_toConsumableArray(_queue));
    Object.defineProperties(this, {
      _timeout: {
        value: timeout
      },
      _queue: {
        value: _queue
      }
    });
  }

  _createClass(Convergence, [{
    key: "timeout",
    value: function timeout(_timeout) {
      if (typeof _timeout !== 'undefined') {
        return new this.constructor(_timeout, this);
      } else {
        return this._timeout;
      }
    }
  }, {
    key: "when",
    value: function when(assertion) {
      return new this.constructor({
        _queue: [{
          assertion: assertion
        }]
      }, this);
    }
  }, {
    key: "once",
    value: function once() {
      console.warn('#once() has been deprecated in favor of #when()');
      return this.when.apply(this, arguments);
    }
  }, {
    key: "always",
    value: function always(assertion, timeout) {
      return new this.constructor({
        _queue: [{
          always: true,
          assertion: assertion,
          timeout: timeout
        }]
      }, this);
    }
  }, {
    key: "do",
    value: function _do(callback) {
      return new this.constructor({
        _queue: [{
          callback: callback
        }]
      }, this);
    }
  }, {
    key: "append",
    value: function append(convergence) {
      if (!isConvergence(convergence)) {
        throw new Error('.append() only works with convergence instances');
      }

      return new this.constructor({
        _queue: convergence._queue
      }, this);
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      var start = Date.now();
      var stats = {
        start: start,
        runs: 0,
        end: start,
        elapsed: 0,
        value: undefined,
        timeout: this._timeout,
        queue: []
      };
      return this._queue.reduce(function (promise, subject, i) {
        if (i === _this._queue.length - 1) {
          subject = Object.assign({
            last: true
          }, subject);
        }

        return promise.then(function (ret) {
          if (subject.assertion) {
            return runAssertion.call(_this, subject, ret, stats);
          } else if (subject.callback) {
            return runCallback.call(_this, subject, ret, stats);
          }
        });
      }, Promise.resolve()).then(function () {
        return stats;
      });
    }
  }, {
    key: "then",
    value: function then() {
      var promise = this.run().then(function (_ref) {
        var value = _ref.value;
        return value;
      });
      return promise.then.apply(promise, arguments);
    }
  }]);

  return Convergence;
}();

Convergence.isConvergence = isConvergence;

exports.isConvergence = isConvergence;
exports.when = when;
exports.always = always;
exports['default'] = Convergence;

Object.defineProperty(exports, '__esModule', { value: true });

})));
